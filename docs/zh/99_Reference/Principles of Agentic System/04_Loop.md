# 04. 递归协议（Ralph Loop）

## 1. 为什么需要 Ralph Loop：三个根本原因

即使引入了 Agent 脚手架（如工具集、提示词模板、结构化输出），智能体系统仍然需要通过 Ralph Loop 的循环迭代机制来逼近目标状态。这不仅仅是技术限制，而是源于智能体执行长程任务时面临的三个根本性挑战：

### 1.1 上下文腐烂（Context Decay）

大语言模型受限于上下文窗口（Context Window），即使引入压缩机制（如摘要、状态快照），这种压缩往往是**有损的**。随着任务的推进，早期的关键细节（如某个边界条件的讨论、某个设计决策的理由）会在压缩过程中丢失。这导致后期的推理可能基于不完整的信息，产生与初始目标不一致的结果。

更严重的是，对话历史的累积会导致"逻辑衰减"：Agent 在处理第 100 轮对话时的推理质量，往往显著低于第 10 轮。这种衰减不是线性的，而是随着上下文长度呈指数级增长。

**Ralph Loop 的应对**: 通过将任务拆分为多个独立的 Session，每个 Session 只需要关注从当前 Milestone 到下一个 Milestone 的增量工作。Session 之间通过持久化的状态快照（Git + Issue 文件）传递信息，而不是依赖于对话历史。这使得每个 Session 都能以"新鲜"的上下文启动，避免累积性的逻辑衰减。

### 1.2 失败模式陷阱（Failure Mode Trap）

Agent 在执行过程中可能陷入一个**失败模式**（Failure Mode），并在之后的尝试中无法脱离。典型的失败模式包括：

- **循环错误修复**: Agent 反复尝试修复同一个错误，但每次修复都引入新的问题，导致无限循环。
- **错误的假设固化**: Agent 在早期做出了错误的假设（如误解了需求），并在后续的所有推理中基于这个假设，导致越走越偏。
- **工具调用死锁**: Agent 陷入了某个工具调用的死循环（如反复读取同一个文件、反复运行失败的测试），无法跳出。

在单个长 Session 中，这种失败模式会持续累积，最终导致整个 Session 无法完成任务。

**Ralph Loop 的应对**: 通过强制性的 Session 切换，系统可以"重置" Agent 的推理状态。新的 Session 会基于持久化的状态快照重新启动，而不会继承前一个 Session 的错误假设或死循环状态。同时，Post-mortem 报告会将前一个 Session 的失败原因结构化，帮助新 Session 避免重复相同的错误。

### 1.3 关注点分离（Separation of Concerns）

即使是看似简单的任务（如"起草一个 Issue Ticket"），在实际执行中也可能需要经历多个步骤：

1. **环境准备**: 安装依赖、配置工具链、初始化项目结构
2. **资料下载**: 从外部源获取文档、代码示例、API 规范
3. **格式转化**: 将 PDF 转为 Markdown、将 Office 文档转为纯文本
4. **调查研究**: 阅读相关代码、分析现有实现、理解业务逻辑
5. **Ticket 填写**: 编写 Acceptance Criteria、Technical Tasks、Review Comments

在基础设施不完善的情况下（如缺少某个工具、网络不稳定、文档格式不兼容），这些步骤可能会遇到各种突发情况。如果将所有步骤硬编码到一个单一的 Session 中，系统会变得极其脆弱：任何一个步骤的失败都会导致整个 Session 失败。

**Ralph Loop 的应对**: 通过循环迭代，系统可以**自适应地**处理这些突发情况，而不需要硬编码所有可能的分支逻辑。每个 Session 只需要关注当前能够完成的步骤，如果遇到阻塞（如某个工具缺失），可以在当前 Session 中安装工具，然后在下一个 Session 中继续执行后续步骤。这种"关注点分离"使得系统能够在不预知所有细节的情况下，逐步逼近目标状态。

---

智能体系统通过引入"递归协议"（Recursive Protocol），将长程执行任务转化为一系列可重试、可接力的循环迭代，这一核心循环被称为 **Ralph Loop**。Ralph Loop 不是简单的算法循环，而是一种类似 TCP 重传机制的系统级执行协议，通过 **Loop（循环重试）+ Relay（接力传递）+ Post-mortem（尸检报告）** 三个核心机制，保证了智能体在长路径任务中的"确定性交付"。

## 2. Ralph Loop 的核心机制：类 TCP 重传协议

Ralph Loop 的设计灵感来自于 TCP 协议的可靠传输机制。在网络通信中，TCP 通过"发送 → 确认 → 重传"的循环，确保数据包最终能够可靠到达目标。类似地，Ralph Loop 通过"执行 → 验证 → 重试"的循环，确保任务最终能够到达目标 Milestone。

### 2.1 Loop（循环重试）：向目标状态靠拢

每个 Agent Session 都是一次"数据包发送"的尝试。Session 的执行过程包含：

1. **读取当前状态**: 从持久化的 Issue 文件中读取当前的 `stage`、已完成的 CheckBox、`files` 列表等状态信息。
2. **执行操作**: Agent 调用工具集对物理环境进行操作（编写代码、运行测试、修改文档等）。
3. **验证结果**: 系统通过 DoD 检查（Definition of Done）和 Invariance 验证，判断本次 Session 是否成功推进了任务状态。

如果验证通过，任务状态向前推进一步（如从 `doing` 到 `review`），这次 Session 的变更被持久化（Git Commit）。如果验证失败，系统会触发下一次循环，基于当前状态重新尝试。

**关键设计**: 每次循环都是基于当前的持久化状态启动的，而不是依赖于前一个 Session 的内存状态。这使得系统能够在任意时刻中断并恢复，而不会丢失已经完成的工作。

### 2.2 Relay（接力传递）：跨 Session 的状态传递

当单个 Agent Session 因为上下文窗口耗尽、超时或其他原因无法继续时，系统会启动一个新的 Session 来"接力"完成剩余工作。这种接力传递通过以下机制实现：

1. **状态快照（State Snapshot）**: 每次 Session 结束时，系统会将当前的物理变更差异（Git Diff）、Milestone 进度、DoD 状态压缩为一个高度结构化的"状态快照"。这个快照包含：
   - 当前 Issue 的 `stage` 和元数据
   - 已完成的 Technical Tasks 和 Acceptance Criteria
   - 变更的文件列表（`files` 字段）
   - 上一次验证的错误信息（如 Lint 诊断）

2. **上下文注入（Context Injection）**: 新的 Session 启动时，系统会将状态快照注入到 Agent 的初始 Prompt 中。Agent 看到的不是冗长的原始对话记录，而是清晰的、事实性的快照。

3. **增量推进（Incremental Progress）**: 每个 Session 只需要关注从当前状态到下一个 Milestone 的增量工作，而不需要重新执行已经完成的步骤。

**关键设计**: 状态快照是基于持久化存储（Git + Issue 文件）的，而不是基于 Agent 的记忆。这使得接力传递不依赖于特定的 Agent 实例，任何 Agent 都可以从快照中恢复执行上下文。

### 2.3 Post-mortem（尸检报告）：失败分析与修复

当 Agent Session 失败时（如验证未通过、工具调用错误、逻辑异常），系统不会简单地重试，而是会生成一份"尸检报告"（Post-mortem Report），分析失败原因并指导下一次循环的修复策略。

尸检报告包含：

1. **失败点定位**: 通过 Lint 诊断、测试失败日志、Git Diff 等信息，精确定位失败发生的位置。
2. **根因分析**: 系统会将失败信息结构化（如 `IssueHookResult` 中的 `diagnostics` 和 `suggestions`），帮助下一个 Session 理解失败的根本原因。
3. **修复建议**: 基于失败类型，系统会提供具体的修复建议（如"运行 `monoco issue lint --fix`"、"清除占位符"、"完成所有 Technical Tasks"）。

**关键设计**: 尸检报告是结构化的、可机读的。下一个 Session 可以直接解析报告中的 `suggestions` 字段，而不需要从自然语言中推断失败原因。这大大提高了修复的成功率。

## 3. 确定性交付：从概率到确定

Ralph Loop 的三个机制共同构成了一个"确定性交付"系统。即使单个 Agent Session 的成功率不是 100%，通过多次循环重试，系统最终能够以接近 100% 的概率完成任务。

这种确定性来自于：

1. **单向进度保证**: 每次成功的循环都会将状态持久化（Git Commit），后续循环不会丢失已完成的工作。即使失败，系统也只会回退到上一个成功的 Milestone，而不是从头开始。

2. **收敛性保证**: 通过 DoD 和 Invariance 的强制验证，系统确保每次循环都在向目标状态靠拢。如果某次循环没有推进状态（如 Lint 错误未修复），系统会阻止 Stage 转换，并在下一次循环中重新尝试。

3. **失败隔离**: 每个 Session 都在独立的隔离环境（Git Branch/Worktree）中执行，失败不会污染主干（Trunk）。只有通过验证的变更才会合并到 Trunk，成为系统真理的一部分。

这种设计使得智能体系统能够处理远超单个模型实例能力范围的复杂任务。即使任务需要数十次循环才能完成，系统也能够通过持久化状态和结构化反馈，最终收敛到目标状态。

## 4. 上下文治理：压缩与传递

为了在 Ralph Loop 的多次迭代中保持执行的一致性，系统必须实施精准的上下文治理。在每个循环结束时，系统会执行以下操作：

1. **状态压缩**: 将当前的物理变更（Git Diff）、Milestone 进度、DoD 状态压缩为结构化的快照。这个快照是高度压缩的，只包含必要的事实信息，而不包含冗长的对话历史。

2. **历史清理**: 对于已经完成的 Milestone，系统会清空不必要的对话历史，只保留关键的"状态摘要"。这有效地解决了上下文膨胀带来的推理能力退化问题。

3. **快照注入**: 新的循环启动时，系统会将压缩后的快照注入到 Agent 的初始 Prompt 中。Agent 看到的是清晰的、事实性的状态描述，而不是混乱的对话记录。

这种做法类似于操作系统在进程切换时的上下文保护，它使得智能体系统的算力可以超越单个模型实例的物理极限，支持无限长程的任务推进。

## 5. 走向自主收敛

Ralph Loop 的终极目标是实现任务的"自发收敛"。在理想的协议约束下，每一个成功的循环都应该让系统向最终的 DoD 状态推进一步。

通过将人类的干预点定位在 Loop 的循环参数设置（即定义阶段）而非 Loop 的执行内部，智能体系统实现了从"人机共同执行"到"人定义、机执行"的范式转移。人类只需要：

1. **定义目标**: 通过 Issue 文件定义任务的 Acceptance Criteria 和 DoD。
2. **设置约束**: 通过 Invariance 规则定义系统不变量。
3. **启动循环**: 通过 `monoco issue start` 启动第一个 Session。

之后，系统会自动执行 Ralph Loop，通过循环重试、接力传递和尸检报告，最终收敛到目标状态。人类只需要在关键的 Milestone 节点（如 `review` 阶段）进行验收，而不需要参与每个循环的执行细节。

这种基于递归协议的自主运行能力，是智能体系统能够提供 10 倍以上生产力跃迁的动力源泉。
