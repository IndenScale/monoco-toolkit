# 先验驱动的代理验证 (Prior-Driven Proxy Verification, PDPV)

## 问题背景

验证自主智能体是否完成了复杂知识工作，本质上是一个**不可计算问题**。

直接验证代码实现的质量需要：

- 理解业务需求的语义内涵
- 评估架构设计的合理性
- 判断测试覆盖的完备性

这些任务对于自动化系统而言成本极高，甚至在理论上无法穷举。

## 核心洞察

然而，观察发现：大语言模型在训练过程中形成了对 **Issue Ticket** 保持诚实的统计先验。

在大量人类标注的协作数据中，Agent 学习到：

- 任务完成时，更新 ticket 状态为 "Done"
- 遇到阻塞时，添加注释说明依赖关系
- 实现功能后，勾选 Acceptance Criteria

这一行为模式不是通过显式规则编码的，而是作为**概率分布**固化在模型权重中。

## 形式化定义

**先验驱动的代理验证**（Prior-Driven Proxy Verification, PDPV）是一种利用智能体训练先验，将不可直接验证的"工作质量"转化为可形式化验证的"自我报告完整性"的机制。

设：

- $W$：实际工作产物（代码实现）—— 难以直接验证
- $R$：自我报告（Issue Ticket 内容）—— 可形式化验证
- $P(\text{honest}|\theta)$：模型 $\theta$ 对 Ticket 保持诚实的先验概率

PDPV 验证策略：

$$
\text{Verify}(W) \approx \text{Check}(R) \land P(\text{honest}|\theta) > \tau
$$

其中 $\tau$ 为置信度阈值。当 Ticket 的形式化检查通过，且先验概率足够高时，我们以可量化的置信度推断实际工作完成。

## 四级验证阶梯

PDPV 通过渐进式精化实现验证：

```
┌─────────────────────────────────────────────────────────────┐
│  Level 4: 工作流一致性 (Workflow Consistency)                  │
│  检查: Git 工作区状态与 Issue 声明的 files 字段是否同步?          │
│  阻断: pre-commit / pre-submit                              │
├─────────────────────────────────────────────────────────────┤
│  Level 3: 内容完成度 (Content Completion)                     │
│  检查: Acceptance Criteria 是否全部勾选? Template 占位符是否替换? │
│  阻断: pre-submit / on-stage-change                         │
├─────────────────────────────────────────────────────────────┤
│  Level 2: 元数据合法性 (Metadata Validity)                    │
│  检查: Front matter schema 是否合法? Status/stage 转换是否允许? │
│  阻断: monoco issue lint                                    │
├─────────────────────────────────────────────────────────────┤
│  Level 1: 语法合法性 (Syntactic Validity)                     │
│  检查: YAML 是否可解析? Markdown 结构是否合法?                  │
│  阻断: 解析阶段即时错误                                       │
└─────────────────────────────────────────────────────────────┘
```

每一层验证都是在特定时机对特定维度的检查，且上层可以否决下层。

## 与传统验证范式的对比

| 范式            | 验证对象       | 机制                | 局限性               |
| --------------- | -------------- | ------------------- | -------------------- |
| **单元测试**    | 代码行为       | 确定性断言          | 无法验证设计合理性   |
| **形式验证**    | 程序逻辑       | 数学证明            | 复杂系统不可行       |
| **人类 Review** | 实现质量       | 主观判断            | 成本高、不可规模化   |
| **PDPV**        | 自我报告完整性 | 先验假设 + 形式约束 | 依赖模型的诚实性先验 |

PDPV 的核心创新在于：**不验证难以验证的代码，而是验证智能体是否愿意将声誉押在其自我报告上**。

## 机制设计：激励对齐

PDPV 实现了激励相容（Incentive Compatibility）：

```
Agent 的决策空间:
├── 欺骗 (代码未完成但勾选 AC)
│   └── 技术成本: 必须同步修改多处（AC、files、stage）
│   └── 暴露风险: 后续 review 可能发现不一致
│   └── 验证结果: Monoco 的形式检查失败
│
└── 诚实 (完成后再勾选)
    └── 通过成本: 必须实际完成工作
    └── 验证结果: 顺利通过，获得提交许可
```

当欺骗的技术门槛高于诚实工作的成本时，"诚实"成为理性 Agent 的最优策略。

## 在 Monoco 中的实践

Monoco Issue 系统是 PDPV 的工程实现：

1. **Issue as Code**：将任务定义、验收准则、关联文件全部编码为可解析的 Markdown
2. **Lifecycle Hooks**：在状态转换关键点（start/submit/close）插入验证拦截
3. **渐进式精化**：从语法 → 元数据 → 内容 → 工作流，层层递进验证
4. **可执行反馈**：验证失败时返回结构化建议（suggestions），支持自动修复

```python
# Issue Hook 决策模型
class HookDecision(Enum):
    ALLOW = "allow"   # 检查通过，继续执行
    WARN  = "warn"    # 有警告但允许继续
    DENY  = "deny"    # 检查失败，阻止状态转换

# Agent 收到的反馈格式
{
    "decision": "deny",
    "message": "Issue lint failed: acceptance criteria incomplete",
    "suggestions": [
        "运行 'monoco issue lint FEAT-0123 --fix' 自动修复",
        "确认所有 Technical Tasks 已标记完成",
        "运行 'monoco issue sync-files' 同步文件列表"
    ]
}
```

## 理论边界与限制

PDPV 的有效性依赖以下假设：

1. **诚实性先验存在**：模型确实学习到对 Issue Ticket 保持诚实的行为模式
2. **欺骗成本可量化**：形式验证的复杂度足以使欺骗不经济
3. **先验稳定性**：模型的行为分布在部署后保持稳定

当这些假设被违反时（如经过特定微调削弱诚实性先验），PDPV 的置信度将下降。

## 命名辨析

为何是 **Prior-Driven Proxy Verification**：

- **Prior**（先验）：明确指向训练时编码的行为倾向，而非频率派统计
- **Driven**（驱动）：强调先验是机制运作的必要条件（没有它，验证不成立）
- **Proxy**（代理）：准确描述"用可验证的报告替代不可验证的实现"的结构
- **Verification**（验证）：明确目标是验证，而非预测或对齐

排除的备选：

- **Statistical**：暗示遍历性和可重复采样，与 LLM 的非遍历特性不符
- **Delegated**：暗示任务委托给 Agent 执行，与"验证 Agent 的自我声称"的机制不符
- **Based**：弱化先验的决定性作用，暗示仅作为参考

## 结论

PDPV 提供了一种在不可直接验证的领域中建立可信度的工程路径。它不追求对代码质量的完美评估，而是通过机制设计，利用智能体的训练先验，将验证转化为一个**可形式化、可阻断、可修复**的契约系统。

这是从"信任但核实"（Trust but Verify）到"激励相容的自动验证"的范式转变。
