# Monoco Toolkit 考古调查报告：从维护到革命 (2026-01-26 至 2026-01-30)

**日期**: 2026年2月1日
**调查员**: Gemini CLI Agent
**对象**: Monoco Toolkit Project
**范围**: 2026年1月26日 与 2026年1月30日 的代码与文档演进

---

## 1. 执行摘要 (Executive Summary)

本次考古调查深入分析了 Monoco Toolkit 在 2026 年 1 月底的关键演进。调查发现，这段时间（特别是 1 月 30 日）标志着该项目从一个“任务管理工具”向“**Agent Native 操作系统**”的重大范式转移。

- **1月26日（维护期）**：重点在于稳固基础。团队发布了多个补丁版本 (0.3.4, 0.3.5)，优化了 Issue 生命周期管理（FEAT-0108），并增强了跨项目引用能力（FEAT-0107）。这一天的活动表现为典型的工程维护和渐进式改进。
- **1月30日（革命期）**：发生了架构级的重构。**FEAT-0118** 完全重写了 Agent CLI，引入了“角色（Role）- 会话（Session）”分离的运行模型。**FEAT-0121** 确立了 "Flow Skills" 标准，使用 Mermaid 图表作为可执行代码（Design as Code），实现了 Kimi CLI 与通用 Agent 的双重兼容。此外，Memo 系统（FEAT-0119）和治理系统（FEAT-0113/0115）也得到了核心增强。

**关键发现**: 2026 年 2 月 1 日（即调查当日），项目执行了一次大规模的“历史归档”操作，大量 Feature Issue 被移动至 `.archives/` 目录。本次调查通过 Git 历史回溯技术，成功还原了这些关键特性的设计原貌。

---

## 2. 考古背景：2月1日大归档事件 (The Great Archival)

在开始详细分析之前，必须记录一个重要的环境发现。

在尝试读取 `Issues/Features/closed/` 目录下的历史 Issue 时，发现文件大量缺失。通过对比 Git 历史与当前工作树，确认在 2026 年 2 月 1 日，项目执行了一次代号为 "Archival" 的操作（相关证据：`ARCHAEOLOGY_REPORT_2026_01_31_02_01.md` 及 `.monoco/project.yaml` 中的归档配置）。

这一操作表明项目可能进入了一个新的迭代周期（如 0.4.x 或 1.0），旧的 Feature 票据被视为“已结项的历史资产”被封存。为了完成本次调查，调查员使用了 `git show <commit_hash>:<path>` 技术，穿透时间迷雾，直接从 Git 对象库中提取了 1 月 30 日的原始设计文档。

---

## 3. 1月26日：维护与优化阶段 (Maintenance & Optimization)

这一天的活动主要集中在提升系统的稳定性和易用性，为后续的大规模重构清理障碍。

### 3.1 发布工程 (Release Engineering)

团队在一天内进行了两次版本发布：

- **v0.3.4**: 常规修复。
- **v0.3.5**: 紧随其后的补丁，可能是为了修复紧急的 Linter 或依赖问题。
- **Git Spike**: 引入了 `chore: add git spike` (307378f)，这表明团队开始系统性地研究 Git 交互模式，为后来的 `git_service.py` 奠定基础。

### 3.2 Issue 生命周期优化 (FEAT-0108)

- **背景**: 在此之前，`monoco issue submit` 命令可能包含一个 `` 标志，用于在提交时清理分支。
- **变更**: 提交 `2898e04` "remove prune flag from submit command" 移除了这一功能。
- **洞察**: 这是一个关键的流程修正。`submit` 仅代表“请求评审”，此时代码尚未合并，分支**绝不应该**被删除。清理工作（Prune）应当且仅应当发生在 `close`（即合并完成）之后。这一变更体现了团队对软件工程生命周期的严谨理解。

### 3.3 基础设施铺垫

- **CHORE-0015 (Agent Prompts)**: "Sync issue best practices to agent prompts"。这表明团队正在尝试让 AI Agent 理解 Monoco 的工作流，这是 "Agent Native" 思想的早期萌芽。

---

## 4. 1月30日：Agent Native 革命 (The Agent Native Revolution)

这一天是 Monoco Toolkit 发展史上的分水岭。代码提交密度极高，且涉及核心架构的根本性变更。

### 4.1 核心架构重构 (FEAT-0118: Role & Session)

在此之前，Agent CLI 可能是一系列松散的命令（如 `draft`, `autopsy`）。FEAT-0118 将其重构为结构化的资源管理模型。

- **新命令体系**:
  - `monoco agent run`: 唯一的启动入口。
  - `monoco agent session`: 管理运行时实例（List, Kill, Logs）。
  - `monoco agent role`: 管理能力模板。
  - `monoco agent provider`: 管理底层引擎（Gemini, Claude, Kimi 等）。
- **标准化角色 (Standardized Roles)**:
  代码中明确定义了六大原子角色，构成了 Agent 协作的基石：
  1.  **Planner**: 架构师，负责拆解 Epic/Feature。
  2.  **Builder (Engineer)**: 开发者，负责编码与测试。
  3.  **Reviewer**: 评审者，负责 Code Review 和 QA。
  4.  **Merger**: 运维，负责合并与发布。
  5.  **Coroner**: 验尸官，负责错误分析（Autopsy）。
  6.  **Manager**: 项目经理，负责任务指派与进度追踪。

这一重构将 Monoco 从一个简单的“命令行工具”提升为一个“**Agent 运行时环境**”（Session Manager），支持多 Agent 协作和持久化会话管理。

### 4.2 Flow Skills 与 "Design as Code" (FEAT-0121)

这是最激动人心的技术创新。团队面临一个挑战：如何让 Kimi CLI（基于自然语言的工具）和通用 Agent（基于 Prompt 的工具）遵循严格的工程标准（如“先测试后提交”）？

- **解决方案**: **Flow Skills**。
- **核心思想**: 使用 **Mermaid 状态机图** 定义工作流。
- **实现机制**:
  - 在 `SKILL.md` 中编写 Mermaid 代码（如 `Investigate -> Code -> Test -> Report -> Submit`）。
  - **Kimi CLI 兼容**: 利用 Kimi 的 `/flow` 特性，强制执行状态跳转。
  - **通用 Agent 兼容**: 将 Mermaid 图作为 Context 注入 System Prompt，利用 LLM 的图形理解能力实现隐式约束。
- **技术细节**:
  - 引入 `monoco_flow_` 前缀注入机制。由于 Kimi 限制扁平化 Skill，Monoco 动态地将 `resources/skills/flow_engineer` 映射为 `.agent/skills/monoco_flow_engineer`。
  - 实现了自动 `.gitignore` 管理，防止注入的 Skill 污染用户仓库。

### 4.3 多技能架构 (FEAT-0122 & CHORE-0021)

配合 FEAT-0121，系统底层的 `SkillManager` 被重写，支持从多个源（Resources, User Config, Plugins）加载 Skill。CHORE-0021 清理了冗余的旧 Skill，将系统收敛到新的 Flow 体系上。

### 4.4 治理系统的强化 (Governance 2.0)

随着 Agent 能力的增强，管控必须同步跟上。

- **自动提交 (FEAT-0115 / git_service.py)**: 引入 `IssueGitService`。当 Issue 状态变更（如 `Start`, `Submit`）时，系统自动生成原子提交（Atomic Commit），如 `chore(issue): start FEAT-0118`。这确保了 Git 历史与任务状态的完美同步。
- **物理域治理 (FEAT-0113 / validator.py)**: 引入了 `Domain Governance`。对于大规模项目（Issue > 128 或 Epic > 32），强制要求 Issue 关联 `domains` 字段，且子 Issue 必须继承或显式声明域。这防止了单体架构腐化。
- **严格分支上下文 (FEAT-0117)**: 强制约束 `create` 必须在 Trunk，`submit` 必须在 Feature Branch。防止了 Agent 在错误的分支上工作。

### 4.5 Memo 系统闭环 (FEAT-0119)

Memo（闪念笔记）系统补齐了最后一块拼图：

- 新增 `monoco memo delete` 命令。
- 新增 I18n 校验：强制检查 Memo 内容是否符合项目源语言（如中文项目禁止纯英文 Memo），保持知识库语言统一。

---

## 5. 技术深度解析 (Technical Deep Dive)

### 5.1 SessionManager 的设计

在 `monoco/features/agent/manager.py` 中，`SessionManager` 采用了类似 Docker 守护进程的设计模式：

```python
class SessionManager:
    def __init__(self, ...):
        # 持久化存储路径 .monoco/sessions/
        self.sessions_dir = self.project_root / ".monoco" / "sessions"

    def create_session(self, issue_id: str, role: RoleTemplate) -> RuntimeSession:
        # 生成唯一 Session ID
        session_id = str(uuid.uuid4())
        # 绑定 Git 分支：agent/{issue_id}/{session_id}
        branch_name = f"agent/{issue_id}/{session_id[:8]}"

        # 实例化 Worker (执行单元)
        worker = Worker(role, issue_id, timeout=timeout)
        # 包装为运行时会话
        runtime = RuntimeSession(..., worker, ...)
        return runtime
```

这种设计将 Agent 的**执行状态**（Worker Process）与**业务状态**（Issue/Branch）解耦，支持了“断点续传”和“后台运行”（Daemon Mode）。

### 5.2 Flow Skills 的注入魔法

在 `monoco/features/agent/flow_skills.py` 中，`sync_flow_skills` 函数展示了精妙的工程实现：

1.  **Discovery**: 扫描 `resources/skills/` 寻找 `type: flow` 的 Skill。
2.  **Injection**: 将其复制到用户的 `.agent/skills/` 目录，并加上 `monoco_flow_` 前缀。
    - _Why Prefix?_ 为了避免与用户自定义 Skill 冲突，并明确命名空间。
3.  **Gitignore**: 自动修改 `.gitignore` 添加 `monoco_flow_*/`。
    - _Why?_ 注入的代码是临时的运行时依赖，不应被提交到用户仓库。

这一机制完美解决了“如何分发标准化工作流到用户本地环境”的问题。

### 5.3 验证器 (Validator) 的防御性编程

`monoco/features/issue/validator.py` 是整个治理系统的核心。它不仅检查语法，还检查**逻辑一致性**：

- **Time Travel Check**: 确保 `created_at <= opened_at <= closed_at`。
- **State Requirement**:
  - 如果 Stage 是 `Doing`，必须有 Task Checkbox。
  - 如果 Stage 是 `Done`，所有 AC 必须打钩 `[x]`。
- **Placeholder Check**: 严厉禁止提交包含 `<!-- TODO -->` 或 `<!-- Placeholder -->` 的 Issue。

---

## 6. 总结与展望 (Conclusion)

从 1 月 26 日到 1 月 30 日，Monoco Toolkit 完成了一次惊人的蜕变。

- **Before (1/26)**: 一个辅助开发者管理 Issue 的 CLI 工具。
- **After (1/30)**: 一个 **Agent Native 操作系统**。它不仅管理任务，还管理**执行任务的数字员工 (Agents)**，并为它们定义了**标准作业程序 (SOP/Flows)**。

**核心哲学转变**:
从 "Tool for Humans" 转变为 "Environment for Agents"。Monoco 不再只是被动等待人类输入命令，而是主动提供环境、规则和工作流，让 Agent 能够自治地（Autonomously）完成软件工程任务。

**未来展望**:
基于 2 月 1 日的大归档和当前的架构，预计下一个版本将重点关注：

1.  **多 Agent 协同**: 基于 SessionManager 实现多个 Role 的并行协作。
2.  **LSP 深度集成**: 将 Flow Skills 的状态机实时反馈到 IDE 中。
3.  **知识引擎**: Memo 系统可能会演化为 Agent 的长期记忆（Long-term Memory）。

---

_报告生成完毕。_
